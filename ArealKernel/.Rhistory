}
y <- c(125, 18, 20, 34)
lis_conv_gd <- c()
for(i in seq(0.11,0.99,by=0.01)){
cat("the initial value is ", i, "\n")
lis_conv_gd <- c(lis_conv_gd, Gradient_descent(i,y, beta=0.8))
}
plot(seq(0.11,0.99,by=0.01), lis_conv_ga)
plot(seq(0.11,0.99,by=0.01), lis_conv_gd)
lis_conv_gd
which(seq(0.11,0.99,by=0.01)==0.8)
lis_conv_gd[70]
# backtracking gamma
Gradient_descent <- function(x0, y, gamma0=0.01, beta=0.5, epsilon=0.001, th=200,
flag=TRUE, flag2=TRUE, flag3=TRUE){
new <- x0
n <- 0
while(flag){
n <- n+1
cat("Iteration", n, "\n")
old <- new
gamma <- gamma0/beta
while(flag2){
prop <- old - gamma*grad(old,y)
flag2 <- (prop<0 || prop>1)
gamma <- beta*gamma
cat("the new gamma is", gamma, "\n")
}
while(flag3){
prop <- old - gamma*grad(old,y)
flag3 <- (loglik(prop,y)>loglik(old,y)-alpha*gamma*grad(old,y)^2)
gamma <- beta*gamma
cat("the new gamma is", gamma, "\n")
}
flag <- (abs(prop-old)>epsilon)
# flag <- (abs(grad(prop,y))>epsilon)
new <- prop
if(n>th){
cat("Algorithm is not converging!!! Iteration reaches threshold.")
return(NULL)
}
}
return(new)
}
y <- c(125, 18, 20, 34)
lis_conv_gd <- c()
for(i in seq(0.11,0.99,by=0.01)){
cat("the initial value is ", i, "\n")
lis_conv_gd <- c(lis_conv_gd, Gradient_descent(i,y, beta=0.8))
}
plot(seq(0.11,0.99,by=0.01), lis_conv_gd)
index <- which(abs(lis_conv_gd-0.627)<0.001)
Gradient_descent(0.8,y,beta=0.8)
# backtracking gamma
Gradient_descent <- function(x0, y, gamma0=0.01, beta=0.5, epsilon=0.001, th=200,
flag=TRUE, flag2=TRUE, flag3=TRUE){
new <- x0
n <- 0
while(flag){
n <- n+1
cat("Iteration", n, "\n")
old <- new
gamma <- gamma0/beta
while(flag2){
prop <- old - gamma*grad(old,y)
flag2 <- (prop<0 || prop>1)
gamma <- beta*gamma
cat("the new gamma is", gamma, "\n")
}
while(flag3){
prop <- old - gamma*grad(old,y)
flag3 <- (loglik(prop,y)>loglik(old,y)-alpha*gamma*grad(old,y)^2)
gamma <- beta*gamma
cat("the new gamma is", gamma, "\n")
}
flag <- (abs(prop-old)>epsilon)
print(abs(prop-old))
# flag <- (abs(grad(prop,y))>epsilon)
new <- prop
if(n>th){
cat("Algorithm is not converging!!! Iteration reaches threshold.")
return(NULL)
}
}
return(new)
}
Gradient_descent(0.8,y,beta=0.8)
# backtracking gamma
Gradient_descent <- function(x0, y, gamma0=0.01, beta=0.5, epsilon=0.001, th=200,
flag=TRUE, flag2=TRUE, flag3=TRUE){
new <- x0
n <- 0
while(flag){
n <- n+1
cat("Iteration", n, "\n")
old <- new
gamma <- gamma0/beta
while(flag2){
prop <- old - gamma*grad(old,y)
flag2 <- (prop<0 || prop>1)
gamma <- beta*gamma
cat("the new gamma is", gamma, "\n")
}
while(flag3){
prop <- old - gamma*grad(old,y)
flag3 <- (loglik(prop,y)>loglik(old,y)-alpha*gamma*grad(old,y)^2)
gamma <- beta*gamma
cat("the new gamma is", gamma, "\n")
}
flag <- (abs(prop-old)>epsilon)
print(abs(prop-old))
# flag <- (abs(grad(prop,y))>epsilon)
new <- prop
cat("new is", new, "\n")
if(n>th){
cat("Algorithm is not converging!!! Iteration reaches threshold.")
return(NULL)
}
}
return(new)
}
Gradient_descent(0.8,y,beta=0.8)
# backtracking gamma
Gradient_descent <- function(x0, y, gamma0=0.01, beta=0.5, epsilon=0.001, th=200,
flag=TRUE, flag2=TRUE, flag3=TRUE){
new <- x0
n <- 0
while(flag){
n <- n+1
cat("Iteration", n, "\n")
old <- new
gamma <- gamma0/beta
while(flag2){
prop <- old - gamma*grad(old,y)
cat("prop is", prop, "\n")
flag2 <- (prop<0 || prop>1)
gamma <- beta*gamma
cat("the new gamma is", gamma, "\n")
}
while(flag3){
prop <- old - gamma*grad(old,y)
cat("prop is", prop, "\n")
flag3 <- (loglik(prop,y)>loglik(old,y)-alpha*gamma*grad(old,y)^2)
gamma <- beta*gamma
cat("the new gamma is", gamma, "\n")
}
flag <- (abs(prop-old)>epsilon)
print(abs(prop-old))
# flag <- (abs(grad(prop,y))>epsilon)
new <- prop
cat("new is", new, "\n")
if(n>th){
cat("Algorithm is not converging!!! Iteration reaches threshold.")
return(NULL)
}
}
return(new)
}
Gradient_descent(0.8,y,beta=0.8)
# backtracking gamma
Gradient_descent <- function(x0, y, gamma0=0.01, beta=0.5, epsilon=0.001, th=200,
flag=TRUE, flag2=TRUE, flag3=TRUE){
new <- x0
n <- 0
while(flag){
n <- n+1
cat("Iteration", n, "\n")
old <- new
gamma <- gamma0/beta
while(flag2){
prop <- old - gamma*grad(old,y)
cat("prop is", prop, "\n")
flag2 <- (prop<0 || prop>1)
gamma <- beta*gamma
cat("the new gamma is", flag2, "\n")
}
while(flag3){
prop <- old - gamma*grad(old,y)
cat("prop is", prop, "\n")
flag3 <- (loglik(prop,y)>loglik(old,y)-alpha*gamma*grad(old,y)^2)
gamma <- beta*gamma
cat("the new gamma is", gamma, "\n")
}
flag <- (abs(prop-old)>epsilon)
print(abs(prop-old))
# flag <- (abs(grad(prop,y))>epsilon)
new <- prop
cat("new is", new, "\n")
if(n>th){
cat("Algorithm is not converging!!! Iteration reaches threshold.")
return(NULL)
}
}
return(new)
}
y <- c(125, 18, 20, 34)
Gradient_descent(0.8,y,beta=0.8)
# backtracking gamma
Gradient_descent <- function(x0, y, gamma0=0.01, beta=0.5, epsilon=0.001, th=200,
flag=TRUE){
new <- x0
n <- 0
while(flag){
n <- n+1
cat("Iteration", n, "\n")
old <- new
gamma <- gamma0/beta
flag2=TRUE; flag3=TRUE
while(flag2){
prop <- old - gamma*grad(old,y)
cat("prop is", prop, "\n")
flag2 <- (prop<0 || prop>1)
gamma <- beta*gamma
cat("the new gamma is", flag2, "\n")
}
while(flag3){
prop <- old - gamma*grad(old,y)
cat("prop is", prop, "\n")
flag3 <- (loglik(prop,y)>loglik(old,y)-alpha*gamma*grad(old,y)^2)
gamma <- beta*gamma
cat("the new gamma is", gamma, "\n")
}
flag <- (abs(prop-old)>epsilon)
print(abs(prop-old))
# flag <- (abs(grad(prop,y))>epsilon)
new <- prop
cat("new is", new, "\n")
if(n>th){
cat("Algorithm is not converging!!! Iteration reaches threshold.")
return(NULL)
}
}
return(new)
}
Gradient_descent(0.8,y,beta=0.8)
# backtracking gamma
Gradient_descent <- function(x0, y, gamma0=0.01, beta=0.5, epsilon=0.001, th=200,
flag=TRUE){
new <- x0
n <- 0
while(flag){
n <- n+1
cat("Iteration", n, "\n")
old <- new
gamma <- gamma0/beta
flag2=TRUE; flag3=TRUE
while(flag2){
prop <- old - gamma*grad(old,y)
flag2 <- (prop<0 || prop>1)
gamma <- beta*gamma
}
while(flag3){
prop <- old - gamma*grad(old,y)
flag3 <- (loglik(prop,y)>loglik(old,y)-alpha*gamma*grad(old,y)^2)
gamma <- beta*gamma
}
flag <- (abs(prop-old)>epsilon)
print(abs(prop-old))
# flag <- (abs(grad(prop,y))>epsilon)
new <- prop
cat("new is", new, "\n")
if(n>th){
cat("Algorithm is not converging!!! Iteration reaches threshold.")
return(NULL)
}
}
return(new)
}
y <- c(125, 18, 20, 34)
lis_conv_gd <- c()
for(i in seq(0.11,0.99,by=0.01)){
cat("the initial value is ", i, "\n")
lis_conv_gd <- c(lis_conv_gd, Gradient_descent(i,y, beta=0.8))
}
plot(seq(0.11,0.99,by=0.01), lis_conv_gd)
plot(seq(0.11,0.99,by=0.01), lis_conv_gd, type="b",
main="Convergence Result of Gradient Descent Algorithm",
xlab="Initial Value", ylab=expression(pi))
abline(h=round(mean(lis_conv),3), col="brown")
# backtracking gamma
Gradient_descent <- function(x0, y, gamma0=0.01, beta=0.5, epsilon=0.001, th=200,
flag=TRUE){
new <- x0
n <- 0
while(flag){
n <- n+1
cat("Iteration", n, "\n")
old <- new
gamma <- gamma0/beta
flag2=TRUE; flag3=TRUE
while(flag2){
prop <- old - gamma*grad(old,y)
flag2 <- (prop<0 || prop>1)
gamma <- beta*gamma
}
while(flag3){
prop <- old - gamma*grad(old,y)
flag3 <- (loglik(prop,y)>loglik(old,y)-alpha*gamma*grad(old,y)^2)
gamma <- beta*gamma
}
# flag <- (abs(prop-old)>epsilon)
flag <- (abs(grad(prop,y))>epsilon)
new <- prop
cat("new is", new, "\n")
if(n>th){
cat("Algorithm is not converging!!! Iteration reaches threshold.")
return(NULL)
}
}
return(new)
}
y <- c(125, 18, 20, 34)
lis_conv_gd <- c()
for(i in seq(0.11,0.99,by=0.01)){
cat("the initial value is ", i, "\n")
lis_conv_gd <- c(lis_conv_gd, Gradient_descent(i,y, beta=0.8))
}
plot(seq(0.11,0.99,by=0.01), lis_conv_gd, type="b",
main="Convergence Result of Gradient Descent Algorithm",
xlab="Initial Value", ylab=expression(pi))
abline(h=round(mean(lis_conv),3), col="brown")
round(mean(lis_conv)
,3)
plot(seq(0.11,0.99,by=0.01), lis_conv_gd, type="b",
main="Convergence Result of Gradient Descent Algorithm",
xlab="Initial Value", ylab=expression(pi))
abline(h=mean(lis_conv), col="brown")
mean(lis_conv)
plot(seq(0.11,0.99,by=0.01), lis_conv_gd, type="b",
main="Convergence Result of Gradient Descent Algorithm",
xlab="Initial Value", ylab=expression(pi))
abline(h=mean(lis_conv), col="brown")
abline(h=mean(lis_conv), col="brown")
# deterministic gamma
Gradient_descent_det <- function(x0, y, beta=0.8, gamma0=0.0001, epsilon=0.01, flag=TRUE){
new <- x0
n <- 0
while(flag){
n <- n + 1
print(n)
old <- new
gamma <- gamma0
new <- old - gamma*grad(old, y)
print(grad(new, y))
flag <- abs(grad(new, y))>epsilon
if(n>200){
break
}
}
return(new)
}
lis_conv
plot(seq(0.11,0.99,by=0.01), lis_conv_gd, type="b",
main="Convergence Result of Gradient Descent Algorithm",
xlab="Initial Value", ylab=expression(pi))
abline(h=mean(lis_conv_gd), col="brown")
mean(lis_conv_gd)
plot(seq(0.11,0.99,by=0.01), lis_conv_gd, type="b",
main=expression(paste("Value of convergence for ", pi, " (0.627 up to 3 d.p)")),
xlab="Initial Value", ylab=expression(pi))
abline(h=mean(lis_conv_gd), col="brown")
range(c(1,4,6))
diff(range(c(1,4,6)))
lis_r <- c()
for(j in 1:1000){
y <- sample(1:2000, 4)
# lis_conv_ <- c()
# for(i in 1:100){
#         lis_conv_ <- c(lis_conv_, EM(runif(1),y))
# }
# lis_mean <- c(lis_mean, mean(lis_conv_))
lis_r <- c(lis_r, diff(range(lis_conv_)))
# if(all(lis_conv_>0 & lis_conv_<1)){
#         lis_mean <- c(lis_mean, mean(lis_conv_))
# }
}
x <- mean(lis_conv)
hist(lis_r)
lis_r
plot(lis_conv_)
plot(lis_conv_, main="Length of Range of convergence value")
plot(lis_conv_, main="Length of Range of convergence value", ylab="Difference")
# arbitrary y
lis_mean <- c()
lis_p <- c()
lis_r <- c()
for(j in 1:1000){
y <- sample(1:2000, 4)
lis_conv_ <- c()
for(i in 1:100){
lis_conv_ <- c(lis_conv_, EM(runif(1),y))
}
# lis_mean <- c(lis_mean, mean(lis_conv_))
lis_r <- c(lis_r, diff(range(lis_conv_)))
# if(all(lis_conv_>0 & lis_conv_<1)){
#         lis_mean <- c(lis_mean, mean(lis_conv_))
# }
}
plot(lis_conv_, main="Length of Range of convergence value", ylab="Difference")
plot(lis_r, main="Length of Range of convergence value", ylab="Difference")
library(SDALGCP)
setwd("~/Documents/PBCanalysis/ArealKernel/SpatialRE")
library(rstan)
bym3.stan <- stan_mode("bym3.stan")
bym3.stan <- stan_modal("bym3.stan")
bym3.stan <- stan_model("bym3.stan")
bym3.stan <- stan_model("bym3.stan")
N <- nrow(PBC.df)
N <- nrow(PBC)
library(randtoolbox)
library(SDALGCP)
library(sf)
library(raster)
library(tidyverse)
library(tictoc)
library(rstanarm)
library(ggplot2)
library(glmnet)
library(dplyr)
library(reshape2)
source("RFFfunc.R")
setwd("~/Documents/PBCanalysis/ArealKernel")
source("RFFfunc.R")
pop_den_ <- raster::intersect(pop_den, PBCshp) %>% replace_na(0)
PBC <- st_as_sf(PBCshp)
PBC_df <- PBC %>% st_set_geometry(NULL)
# value: population density per cell
# weight: the proportion of cell intersected with the polygon
# W: weighted population density per grid intersection with polygon
sf_poly_ <- raster::extract(pop_den_, PBC, cellnumbers=TRUE, small=TRUE,
weights=TRUE, normalizeWeights=FALSE)
lis_centr <- sapply(sf_poly_, function(x) cbind(x, scale(coordinates(pop_den_))[x[,1],]))
lis_wcentr <- sapply(lis_centr, check.0)
# find the exposure risk
pop_den_reg <- sapply(lis_centr, function(x) sum(x[,"value"] * x[,"weight"]))
exposure <- PBC_df$pop/pop_den_reg
# check the distribution of population density
hist(unlist(sapply(lis_wcentr, function(x) x[, "W"])))
table(unlist(sapply(lis_wcentr, function(x) sum(x[, "W"]))))
table(unlist(sapply(lis_wcentr, function(x) sum(x[, "W"]*x[,"weight"]))))
count <- PBC$X
alphas <- seq(0.2, 1, length.out = 30)
lis_Phi.null <- list()
lis_Phi <- list()
lis_Phi_ <- list()
for(i in 1:length(alphas)){
alpha <- alphas[i]
lis_Phi.null[[i]] <- sim.rff(lis_wcentr, alpha=alpha)
lis_Phi[[i]] <-  lis_Phi.null[[i]] %>% as.data.frame() %>%
dplyr::mutate(count=PBC_df$X)
lis_Phi_[[i]] <- lis_Phi[[i]] %>%
cbind(dplyr::select(PBC_df, Income, Crime, Environment, Employment,
Barriers, propmale, Education))
}
bym3.stan <- stan_model("bym3.stan")
bym3.stan <- stan_model("SpatialRE/bym3.stan")
mat.desgn <- lis_Phi.null[[8]]
N <- nrow(PBC)
mat.desgn <- lis_Phi.null[[8]]
N
dim(mat.desgn)
class(mat.desgn)
options(mc.cores = parallel::detectCores())
bym3.fit <- sampling(bym3.stan, data=list(N,count,exposure,l,mat.desgn),
control = list(adapt_delta = 0.97),
chains=3, warmup=7000, iter=8000, save_warmup=FALSE);
N <- nrow(PBC)
l <- 2*100
mat.desgn <- lis_Phi.null[[8]]
bym3.stan <- stan_model("SpatialRE/bym3.stan")
bym3.fit <- sampling(bym3.stan, data=list(N,count,exposure,l,mat.desgn),
control = list(adapt_delta = 0.97),
chains=3, warmup=7000, iter=8000, save_warmup=FALSE);
N
class(N)
N <- as.numeric(nrow(PBC))
N
class(N)
bym3.fit <- sampling(bym3.stan, data=list(N,count,exposure,l,mat.desgn),
control = list(adapt_delta = 0.97),
chains=3, warmup=7000, iter=8000, save_warmup=FALSE);
class(count)
count <- as.integer(count)
count
l
N <- as.integer(nrow(PBC))
l <- as.integer(2*100)
count <- as.integer(count)
mat.desgn <- lis_Phi.null[[8]]
bym3.stan <- stan_model("SpatialRE/bym3.stan")
bym3.fit <- sampling(bym3.stan, data=list(N,count,exposure,l,mat.desgn),
control = list(adapt_delta = 0.97),
chains=3, warmup=7000, iter=8000, save_warmup=FALSE);
bym3.fit <- sampling(bym3.stan, data=list(N=N,y=count,E=exposure,l=l,L=mat.desgn),
control = list(adapt_delta = 0.97),
chains=3, warmup=7000, iter=8000, save_warmup=FALSE);
model <- stan_model(model_code = "parameters { real<lower = 0> y; }
transformed parameters { real<upper = -1> z = y; }")
fit <- sampling(model)
install.packages("rstan", type = "source")
install.packages("rstan", type = "source")
install.packages("rstan", type = "source")
install.packages("rstan", type = "source")
detach(rstan)
detach("package:rstan", unload = TRUE)
detach("package::rstan", unload = TRUE)
detach("rstan", unload = TRUE)
?detach
.packages()
select(PB)
select(PBC)
install.packages("rstan", type = "source")
